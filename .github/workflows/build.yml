name: Build
on:
  # push:
  #   branches:
  #     - main
  #     - beta
  # pull_request:
  workflow_dispatch:
    inputs:
      binary_mode:
        description: '二进制构建模式'
        type: choice
        default: 'build'
        options:
          - 'skip'          # 跳过构建（仅测试）
          - 'build'         # 正常构建（使用缓存）
          - 'force_rebuild' # 强制重新构建（忽略缓存）
      release_mode:
        description: '发布模式'
        type: choice
        default: 'normal'
        options:
          - 'skip'            # 跳过发布
          - 'normal'          # 正常发布（已存在版本跳过）
          - 'force_republish' # 强制重新发布（覆盖已存在版本）
      test_mode:
        description: '测试模式'
        type: choice
        default: 'all'
        options:
          - 'all'              # 运行所有测试
          - 'standalone'       # 仅 standalone 测试
          - 'model_dependent'  # 仅 model dependent 测试
          - 'skip'             # 跳过所有测试
      build_platforms:
        description: '构建平台 (可多选，逗号分隔: win-1,win-2,linux-1,linux-2,mac-x64,mac-arm64)'
        type: string
        default: 'all'
        # 可选值: all, windows, linux, macos, win-1, win-2, linux-1, linux-2, mac-x64, mac-arm64

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"
      - name: Install modules
        run: pnpm install
      - name: Build
        run: pnpm run build
      - name: Download latest llama.cpp release
        env:
          CI: true
        run: node ./dist/cli/cli.js source download --release latest --skipBuild --noBundle --noUsageExample --updateBinariesReleaseMetadataAndSaveGitBundle
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          include-hidden-files: true
          name: "build"
          path: "dist"
      - name: Upload packed templates artifact
        uses: actions/upload-artifact@v4
        with:
          include-hidden-files: true
          name: "build-templates"
          path: "templates/packed"
      - name: Upload llama.cpp artifact
        uses: actions/upload-artifact@v4
        with:
          include-hidden-files: true
          name: "llama.cpp"
          path: |
            llama/binariesGithubRelease.json
            llama/llama.cpp.info.json
            llama/llama.cpp
            llama/gitRelease.bundle

  build-binaries:
    name: Build binaries - ${{ matrix.config.name }}
    # Note: We don't use job-level 'if' here because it prevents matrix expansion
    # All skip logic is handled in the check-platform step
    needs:
      - build
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - name: "Windows (1)"
            os: windows-2022
            artifact: "win-1"
            platform_group: "windows"
          - name: "Windows (2)"
            os: windows-2022
            artifact: "win-2"
            platform_group: "windows"
          - name: "Ubuntu (1)"
            os: ubuntu-22.04
            artifact: "linux-1"
            platform_group: "linux"
          - name: "Ubuntu (2)"
            os: ubuntu-22.04
            artifact: "linux-2"
            platform_group: "linux"
          - name: "macOS x64"
            os: macos-15-intel
            artifact: "mac-x64"
            platform_group: "macos"
          - name: "macOS arm64"
            os: macos-26
            artifact: "mac-arm64"
            platform_group: "macos"
    steps:
      - name: Check if platform should be built
        id: check-platform
        shell: bash
        run: |
          # First check if entire job should be skipped based on inputs/commit message
          SHOULD_SKIP_JOB="false"

          # For workflow_dispatch: only skip if binary_mode is 'skip'
          # Note: release_mode='skip' should NOT skip building, only skip publishing
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ inputs.binary_mode }}" = "skip" ]; then
              SHOULD_SKIP_JOB="true"
              echo "Skipping: binary_mode is 'skip'"
            fi
          else
            # For push/pull_request: check commit message tags
            # Note: [skip-release] should NOT skip building, only skip publishing
            COMMIT_MSG="${{ github.event.head_commit.message }}"
            if [[ "$COMMIT_MSG" == *"[skip-binaries]"* ]] || \
               [[ "$COMMIT_MSG" == *"[skip-build]"* ]]; then
              SHOULD_SKIP_JOB="true"
              echo "Skipping: commit message contains skip tag"
            fi
          fi

          if [ "$SHOULD_SKIP_JOB" = "true" ]; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Now check platform selection
          BUILD_PLATFORMS="${{ inputs.build_platforms || 'all' }}"
          BUILD_PLATFORMS=$(echo "$BUILD_PLATFORMS" | tr -d ' ')
          ARTIFACT="${{ matrix.config.artifact }}"
          PLATFORM_GROUP="${{ matrix.config.platform_group }}"

          echo "BUILD_PLATFORMS: '$BUILD_PLATFORMS'"
          echo "ARTIFACT: '$ARTIFACT'"
          echo "PLATFORM_GROUP: '$PLATFORM_GROUP'"

          # Function to check if a value is in a comma-separated list
          contains_value() {
            local list="$1"
            local value="$2"
            # Add commas to both ends to ensure exact matching
            [[ ",$list," == *",$value,"* ]]
          }

          if [ "$BUILD_PLATFORMS" = "all" ] || [ -z "$BUILD_PLATFORMS" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Building all platforms, including $ARTIFACT"
          elif contains_value "$BUILD_PLATFORMS" "$ARTIFACT"; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Platform $ARTIFACT explicitly included"
          elif contains_value "$BUILD_PLATFORMS" "$PLATFORM_GROUP"; then
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "Platform group $PLATFORM_GROUP matches, building $ARTIFACT"
          else
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "Skipping $ARTIFACT (not in: $BUILD_PLATFORMS)"
          fi

      - uses: actions/checkout@v4
        if: steps.check-platform.outputs.should_build == 'true'
      - uses: pnpm/action-setup@v4
        if: steps.check-platform.outputs.should_build == 'true'
        with:
          version: 10
      - uses: actions/setup-node@v4
        if: steps.check-platform.outputs.should_build == 'true'
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Download build artifact
        if: steps.check-platform.outputs.should_build == 'true'
        uses: actions/download-artifact@v4
        with:
          name: build
          path: dist
      - name: Download llama.cpp artifact
        if: steps.check-platform.outputs.should_build == 'true'
        uses: actions/download-artifact@v4
        with:
          name: llama.cpp
          path: llama

      - name: Get llama.cpp version for cache
        if: steps.check-platform.outputs.should_build == 'true'
        id: llama-cpp-version
        shell: bash
        run: |
          # Use tag/release name instead of commit hash for cache key
          # Commit hash changes after squash even if content is identical
          # Tag is stable and doesn't change

          # First, try to get tag from llama.cpp.info.json
          VERSION=$(cat llama/llama.cpp.info.json 2>/dev/null | jq -r '.tag // .commit // "unknown"' || echo "unknown")

          if [ "$VERSION" = "unknown" ] && [ -d "llama/llama.cpp/.git" ]; then
            # Ensure refs directory exists (may be missing from artifacts)
            mkdir -p llama/llama.cpp/.git/refs/heads llama/llama.cpp/.git/refs/tags llama/llama.cpp/.git/refs/remotes

            # Try to get tag from git
            VERSION=$(cd llama/llama.cpp && git --git-dir=.git describe --tags --exact-match 2>/dev/null || echo "")

            # If no exact tag, try to get commit hash
            if [ -z "$VERSION" ]; then
              VERSION=$(cd llama/llama.cpp && git --git-dir=.git rev-parse HEAD 2>/dev/null || echo "unknown")
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "llama.cpp version for cache: $VERSION"

      - name: Cache prebuilt binaries
        id: cache-binaries
        if: steps.check-platform.outputs.should_build == 'true' && inputs.binary_mode != 'force_rebuild'
        uses: actions/cache@v4
        with:
          path: bins
          key: prebuilt-binaries-${{ matrix.config.artifact }}-${{ steps.llama-cpp-version.outputs.version }}-${{ hashFiles('llama/addon/**', 'llama/CMakeLists.txt') }}

      - name: Determine if build is required
        id: determine-build
        if: steps.check-platform.outputs.should_build == 'true'
        shell: bash
        run: |
          if [[ "${{ steps.cache-binaries.outputs.cache-hit }}" == 'true' ]]; then
            if [[ -d "bins" && -n "$(ls -A bins)" ]]; then
              echo "Cache hit and 'bins' is not empty. Build not required."
              echo "build_required=false" >> $GITHUB_OUTPUT
            else
              echo "Cache hit, but 'bins' directory is empty or missing. Build is required."
              echo "build_required=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "Cache not hit or rebuild is forced. Build is required."
            echo "build_required=true" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies on Windows
        if: steps.check-platform.outputs.should_build == 'true' && startsWith(matrix.config.os, 'windows') && steps.determine-build.outputs.build_required == 'true'
        run: |
          choco install cmake.install --version=3.31.1
          choco install cmake --version=3.31.1
          choco install ninja

      - name: Install dependencies on Ubuntu (1)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Ubuntu (1)' && steps.determine-build.outputs.build_required == 'true'
        run: |
          sudo bash .github/scripts/setup-apt-mirror.sh || true
          sudo apt-get update
          sudo apt-get install ninja-build libtbb-dev g++-aarch64-linux-gnu gcc-aarch64-linux-gnu g++-arm-linux-gnueabihf gcc-arm-linux-gnueabihf clang libomp-dev

          wget -c https://github.com/Kitware/CMake/releases/download/v3.31.7/cmake-3.31.7-linux-x86_64.tar.gz
          sudo tar --strip-components=1 -C /usr/local -xzf cmake-3.31.7-linux-x86_64.tar.gz
          rm -f ./cmake-3.31.7-linux-x86_64.tar.gz

          which aarch64-linux-gnu-gcc
          which aarch64-linux-gnu-g++

          which arm-linux-gnueabihf-gcc
          which arm-linux-gnueabihf-g++

          cmake --version

      - name: Install dependencies on Ubuntu (2)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Ubuntu (2)' && steps.determine-build.outputs.build_required == 'true'
        run: |
          sudo bash .github/scripts/setup-apt-mirror.sh || true
          sudo apt-get update
          sudo apt-get install ninja-build libtbb-dev clang libomp-dev

          wget -c https://github.com/Kitware/CMake/releases/download/v3.31.7/cmake-3.31.7-linux-x86_64.tar.gz
          sudo tar --strip-components=1 -C /usr/local -xzf cmake-3.31.7-linux-x86_64.tar.gz
          rm -f ./cmake-3.31.7-linux-x86_64.tar.gz

          cmake --version

      - name: Install Cuda 13.0 on Windows (1)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Windows (1)' && steps.determine-build.outputs.build_required == 'true'
        shell: bash
        timeout-minutes: 60
        run: |
          curl -Lo cuda_13.0.0_windows_network.exe https://developer.download.nvidia.com/compute/cuda/13.0.0/network_installers/cuda_13.0.0_windows_network.exe

          echo "Installing Cuda 13.0.0"
          powershell -Command "Start-Process -FilePath cuda_13.0.0_windows_network.exe -ArgumentList '-s','-n' -Wait"
          echo "Cuda installation finished"

          rm -f ./cuda_13.0.0_windows_network.exe

          echo "where cudart64_13.dll: $(where cudart64_13.dll)"

          echo "CUDA_PATH=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v13.0" >> $GITHUB_ENV
          echo "CUDA_PATH_V13_0=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v13.0" >> $GITHUB_ENV
          echo "CUDA_PATH_VX_Y=CUDA_PATH_V13_0" >> $GITHUB_ENV
          echo "C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v13.0\\bin" >> $GITHUB_PATH

      - name: Install Cuda 12.4 on Windows (2)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Windows (2)' && steps.determine-build.outputs.build_required == 'true'
        uses: Jimver/cuda-toolkit@v0.2.15
        with:
          cuda: '12.4.0'
          method: 'network'
          sub-packages: '["nvcc", "cudart", "cublas", "cublas_dev", "thrust", "visual_studio_integration"]'
          use-local-cache: false

      - name: Install Cuda 13.0 on Ubuntu (1)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Ubuntu (1)' && steps.determine-build.outputs.build_required == 'true'
        uses: Jimver/cuda-toolkit@v0.2.27
        with:
          cuda: '13.0.0'
          method: 'network'

      - name: Install Cuda 12.4 on Ubuntu (2)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Ubuntu (2)' && steps.determine-build.outputs.build_required == 'true'
        uses: Jimver/cuda-toolkit@v0.2.15
        with:
          cuda: '12.4.0'
          method: 'network'

      - name: Install Vulkan SDK on Windows (1)
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Windows (1)' && steps.determine-build.outputs.build_required == 'true'
        shell: powershell
        env:
          VULKAN_VERSION: 1.4.313.2
        run: |
          curl.exe -o $env:RUNNER_TEMP/VulkanSDK-Installer.exe -L "https://sdk.lunarg.com/sdk/download/${env:VULKAN_VERSION}/windows/vulkansdk-windows-X64-${env:VULKAN_VERSION}.exe"
          & "$env:RUNNER_TEMP\VulkanSDK-Installer.exe" --accept-licenses --default-answer --confirm-command install
          Add-Content $env:GITHUB_ENV "VULKAN_SDK=C:\VulkanSDK\${env:VULKAN_VERSION}"
          Add-Content $env:GITHUB_PATH "C:\VulkanSDK\${env:VULKAN_VERSION}\bin"

      - name: Install Vulkan SDK on Ubuntu
        if: steps.check-platform.outputs.should_build == 'true' && matrix.config.name == 'Ubuntu (1)' && steps.determine-build.outputs.build_required == 'true'
        run: |
          sudo bash .github/scripts/setup-apt-mirror.sh || true
          wget -qO- https://packages.lunarg.com/lunarg-signing-key-pub.asc | sudo tee /etc/apt/trusted.gpg.d/lunarg.asc
          sudo wget -qO /etc/apt/sources.list.d/lunarg-vulkan-jammy.list https://packages.lunarg.com/vulkan/lunarg-vulkan-jammy.list
          sudo apt update
          sudo apt install vulkan-sdk

      - name: Install dependencies on macOS
        if: steps.check-platform.outputs.should_build == 'true' && startsWith(matrix.config.platform_group, 'macos') && steps.determine-build.outputs.build_required == 'true'
        run: |
          brew install cmake ninja
          alias make=cmake

      - name: Setup & Build
        if: steps.check-platform.outputs.should_build == 'true' && steps.determine-build.outputs.build_required == 'true'
        shell: bash
        timeout-minutes: 300
        env:
          ARTIFACT_NAME: ${{ matrix.config.artifact }}
        run: |
          pnpm install

          pnpm zx -y <<'EOF'

          async function getLatestNodeVersions(maxDate) {
            const res = await fetch("https://nodejs.org/dist/index.json");
            const data = await res.json();
            const versions = new Map();
            let latestVersion = null;

            for (const version of data) {
              const majorVersion = Number(version.version.split(".")[0].slice("v".length));
              const versionDate = new Date(version.date);

              if (maxDate != null && versionDate.getTime() > maxDate)
                continue;

              if (!versions.has(majorVersion)) {
                versions.set(majorVersion, version.version);
              }

              if (latestVersion === null || majorVersion > latestVersion) {
                latestVersion = majorVersion;
              }
            }

            return {versions, latestVersion};
          }

          const {versions: latestNodeVersions} = await getLatestNodeVersions(Date.now() - 1000 * 60 * 60 * 24 * 14);

          const nodeVersion = latestNodeVersions.get(20);
          const windowsOnArmNodeVersion = latestNodeVersions.get(20);

          if (nodeVersion == null || windowsOnArmNodeVersion == null) {
            throw new Error("Could not find node versions");
          }

          $.verbose = true;
          await $`mkdir -p bins`;

          async function buildBinary(arch, flags = [], nodeTarget = nodeVersion) {
            console.log(`Building ${arch} for node ${nodeTarget} with flags`, flags);

            await $`node ./dist/cli/cli.js source build --ciMode --noUsageExample --arch ${arch} --nodeTarget ${nodeVersion} ${flags}`;
          }

          // build binaries
          if (process.env.ARTIFACT_NAME === "win-1") {
            await buildBinary("x64", ["--gpu", "false"]);
            await buildBinary("x64", ["--gpu", "cuda"]);
            await buildBinary("x64", ["--gpu", "vulkan"]);
          } else if (process.env.ARTIFACT_NAME === "win-2") {
            await buildBinary("arm64", ["--gpu", "false"], windowsOnArmNodeVersion);
            await buildBinary("x64", ["--gpu", "cuda"]);
          } else if (process.env.ARTIFACT_NAME === "linux-1") {
            await buildBinary("x64", ["--gpu", "false"]);
            await buildBinary("x64", ["--gpu", "cuda"]);
            await buildBinary("x64", ["--gpu", "vulkan"]);
            await buildBinary("arm64", ["--gpu", "false"]);
            await buildBinary("armv7l", ["--gpu", "false"]);
          } else if (process.env.ARTIFACT_NAME === "linux-2") {
            await buildBinary("x64", ["--gpu", "cuda"]);
          } else if (process.env.ARTIFACT_NAME === "mac-x64") {
            await buildBinary("x64", ["--gpu", "false"]);
          } else if (process.env.ARTIFACT_NAME === "mac-arm64") {
            await buildBinary("arm64", ["--gpu", "metal"]);
          }

          // move binaries to bins
          const localBuildsDirectoryPath = path.join(process.cwd(), "llama", "localBuilds");
          const llamaBinsDirectoryPath = path.join(process.cwd(), "bins");
          for (const folderName of await fs.readdir(localBuildsDirectoryPath)) {
            await fs.move(
              path.join(localBuildsDirectoryPath, folderName, "Release"),
              path.join(llamaBinsDirectoryPath, folderName)
            );
          }

          if (process.env.ARTIFACT_NAME === "win-2") {
            await fs.move(
              path.join(llamaBinsDirectoryPath, "win-x64-cuda"),
              path.join(llamaBinsDirectoryPath, "win-x64-cuda-2")
            );

            if (!(await fs.pathExists(path.join(llamaBinsDirectoryPath, "win-x64-cuda-2", "ggml-cuda.dll")))) {
              throw new Error("ggml-cuda.dll not found in win-x64-cuda-2");
            }
          } else if (process.env.ARTIFACT_NAME === "linux-2") {
            await fs.move(
              path.join(llamaBinsDirectoryPath, "linux-x64-cuda"),
              path.join(llamaBinsDirectoryPath, "linux-x64-cuda-2")
            );

            if (!(await fs.pathExists(path.join(llamaBinsDirectoryPath, "linux-x64-cuda-2", "libggml-cuda.so")))) {
              throw new Error("libggml-cuda.so not found in linux-x64-cuda-2");
            }
          }

          await $`echo "Built binaries:"`;
          await $`ls bins`;

          EOF

      # - name: Clean old caches
      #   if: steps.build.outcome == 'success'
      #   shell: bash
      #   continue-on-error: true
      #   env:
      #     GH_TOKEN: ${{ github.token }}
      #   run: |
      #     echo "Cleaning old caches for artifact: ${{ matrix.config.artifact }}"

      #     # 列出所有匹配的缓存
      #     CACHE_KEY_PREFIX="prebuilt-binaries-${{ matrix.config.artifact }}-"

      #     # 使用 gh CLI 列出并删除旧缓存
      #     # 注意：这会删除所有匹配该前缀的缓存，新的缓存会在此步骤之后自动保存
      #     if command -v gh &> /dev/null; then
      #       echo "Listing caches with prefix: $CACHE_KEY_PREFIX"
      #       gh cache list --limit 100 | grep "$CACHE_KEY_PREFIX" | cut -f1 | while read -r cache_id; do
      #         if [ -n "$cache_id" ]; then
      #           echo "Deleting cache: $cache_id"
      #           gh cache delete "$cache_id" || echo "Failed to delete cache $cache_id (may already be deleted)"
      #         fi
      #       done
      #       echo "Old caches cleaned"
      #     else
      #       echo "GitHub CLI not found, skipping cache cleanup"
      #     fi

      - name: Publish artifact
        if: steps.check-platform.outputs.should_build == 'true'
        uses: actions/upload-artifact@v4
        with:
          include-hidden-files: true
          name: "bins-${{ matrix.config.artifact }}"
          path: "bins/*"

  resolve-next-release:
    name: Resolve next release
    # Skip if release_mode is 'skip' or binary_mode is 'skip'
    if: |-
      (github.event_name != 'workflow_dispatch' || (inputs.binary_mode != 'skip' && inputs.release_mode != 'skip')) &&
      (github.event_name == 'workflow_dispatch' || (
        !contains(github.event.head_commit.message || '', '[skip-binaries]') &&
        !contains(github.event.head_commit.message || '', '[skip-build]')
      ))
    runs-on: ubuntu-latest
    needs:
      - build
    permissions:
      pages: read
      id-token: write
      contents: read
      issues: read
      pull-requests: read
      discussions: read
    outputs:
      next-version: ${{ steps.save-next-version.outputs.next-version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
      - name: Install modules
        run: pnpm install
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build
          path: dist
      - name: Download llama.cpp artifact
        uses: actions/download-artifact@v4
        with:
          name: llama.cpp
          path: llama
      - name: Apply fix patch on semantic-release, to not check for push permission on dry run
        run: |
          patch -p1 --ignore-whitespace < ./scripts/patches/semantic-release+24.1.1.patch
          patch -p1 --ignore-whitespace < ./scripts/patches/@semantic-release+npm+13.1.2.patch
      - name: Resolve next release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: pnpm vite-node ./scripts/resolveNextReleaseVersion.ts --saveReleaseToFile ./semanticReleaseDryRunReleaseResult.json --saveVersionToFile ./resolvedNextVersion.txt
      - name: Save next version output
        id: save-next-version
        run: echo "next-version=$(cat ./resolvedNextVersion.txt)" >> $GITHUB_OUTPUT
      - name: Update job summary
        run: |
          if [ "$(cat ./resolvedNextVersion.txt)" == "false" ]; then
            echo "Next release version: \`N/A\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "Next release version: \`$(cat ./resolvedNextVersion.txt)\`" >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload resolved release artifact
        uses: actions/upload-artifact@v4
        with:
          include-hidden-files: true
          name: "resolved-next-release"
          path: "./semanticReleaseDryRunReleaseResult.json"

  standalone-tests:
    name: Standalone tests
    # Run if test_mode is 'all' or 'standalone'
    if: |
      github.event_name != 'workflow_dispatch' || (inputs.test_mode == 'all' || inputs.test_mode == 'standalone')
    runs-on: ubuntu-22.04
    needs:
      - build
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build
          path: dist

      - name: Download llama.cpp artifact
        uses: actions/download-artifact@v4
        with:
          name: llama.cpp
          path: llama

      - name: Install dependencies on ubuntu
        run: |
          sudo bash .github/scripts/setup-apt-mirror.sh || true
          sudo apt-get update
          sudo apt-get install ninja-build cmake

      - name: Install modules
        run: pnpm install

      - name: Build binary
        run: node ./dist/cli/cli.js source build --noUsageExample --gpu false

      - name: Run standalone tests
        run: pnpm run test:standalone

  model-dependent-tests:
    name: Model dependent tests
    # Run if test_mode is 'all' or 'model_dependent'
    if: |
      github.event_name != 'workflow_dispatch' || (inputs.test_mode == 'all' || inputs.test_mode == 'model_dependent')
    runs-on: macos-26
    env:
      NODE_LLAMA_CPP_GPU: false
    needs:
      - build
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: build
          path: dist

      - name: Download llama.cpp artifact
        uses: actions/download-artifact@v4
        with:
          name: llama.cpp
          path: llama

      - name: Install dependencies on macOS
        if: startsWith(matrix.config.os, 'macos')
        run: |
          brew install cmake ninja
          alias make=cmake

      - name: Install modules
        run: pnpm install

      - name: Build binary
        run: node ./dist/cli/cli.js source build --noUsageExample --gpu false

      - name: Inspect hardware
        run: node ./dist/cli/cli.js inspect gpu

      - name: Download models or ensure all models are downloaded
        id: download-all-test-models
        run: pnpm run dev:setup:downloadAllTestModels --group essential

      - name: Run model dependent tests
        env:
          NODE_OPTIONS: "--max-old-space-size=4096"
        run: pnpm vitest run test/modelDependent/stableCode test/modelDependent/bge test/modelDependent/bgeReranker test/modelDependent/nomicEmbedText


  release:
    name: Release
    # Skip if release_mode is 'skip' or binary_mode is 'skip', or no next version
    if: |-
      (github.event_name != 'workflow_dispatch' || (inputs.binary_mode != 'skip' && inputs.release_mode != 'skip')) &&
      (github.event_name == 'workflow_dispatch' || (
        !contains(github.event.head_commit.message || '', '[skip-binaries]') &&
        !contains(github.event.head_commit.message || '', '[skip-build]')
      )) &&
      needs.resolve-next-release.outputs.next-version != '' &&
      needs.resolve-next-release.outputs.next-version != 'false'
    runs-on: ubuntu-latest
    concurrency: release-${{ github.ref }}
    environment:
      name: npm
      url: ${{ steps.set-npm-url.outputs.npm-url }}
    permissions:
      id-token: write
      contents: write
      issues: write
      pull-requests: write
      discussions: write
    needs:
      - resolve-next-release
      - build
      - build-binaries
    outputs:
      package-version: ${{ steps.set-package-version.outputs.package-version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true
          lfs: true
      - uses: pnpm/action-setup@v4
        with:
          version: 10
      - uses: actions/setup-node@v4
        with:
          node-version: "22"
          cache: "pnpm"
      - name: Install modules
        run: pnpm install
      - uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: Move artifacts
        run: |
          mkdir -p bins
          mv artifacts/bins-*/* bins/
          mv artifacts/build dist/

          mkdir -p ./bins/win-x64-cuda/fallback
          mv ./bins/win-x64-cuda-2/ggml-cuda.dll ./bins/win-x64-cuda/fallback/ggml-cuda.dll
          rm -rf ./bins/win-x64-cuda-2

          mkdir -p ./bins/linux-x64-cuda/fallback
          mv ./bins/linux-x64-cuda-2/libggml-cuda.so ./bins/linux-x64-cuda/fallback/libggml-cuda.so
          rm -rf ./bins/linux-x64-cuda-2

          cp -r artifacts/llama.cpp/llama.cpp/grammars llama/grammars

          rm -f ./llama/binariesGithubRelease.json
          mv artifacts/llama.cpp/binariesGithubRelease.json ./llama/binariesGithubRelease.json

          rm -f ./llama/llama.cpp.info.json
          mv artifacts/llama.cpp/llama.cpp.info.json ./llama/llama.cpp.info.json

          rm -f ./llama/gitRelease.bundle
          mv artifacts/llama.cpp/gitRelease.bundle ./llama/gitRelease.bundle

          mv artifacts/build-templates templates/packed/
          rm -f ./templates/package.json
          rm -f ./templates/package-lock.json

          echo "Built binaries:"
          ls bins
      - name: Move binaries to standalone prebuilt binary modules
        run: pnpm vite-node ./scripts/movePrebuiltBinariesToStandaloneModules.ts
      - name: Prepare standalone prebuilt binary modules
        run: pnpm vite-node ./scripts/prepareStandalonePrebuiltBinaryModules.ts
      - name: Add "postinstall" script to package.json
        run: pnpm run addPostinstallScript
      - name: Move semanticReleaseDryRunReleaseResult.json artifact
        run: mv artifacts/resolved-next-release/semanticReleaseDryRunReleaseResult.json ./semanticReleaseDryRunReleaseResult.json
      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          GH_RELEASE_REF: ${{ github.ref }}
          FORCE_REPUBLISH_PREBUILT: ${{ inputs.release_mode == 'force_republish' }}
        run: |
          echo "//registry.npmjs.org/:_authToken=\${NPM_TOKEN}" > ~/.npmrc
          export DRY_RUN_RESULT_FILE_PATH="$(pwd)/semanticReleaseDryRunReleaseResult.json"

          patch -p1 --ignore-whitespace < ./scripts/patches/@semantic-release+github+11.0.0.patch
          pnpm semantic-release
      - name: Set npm package url to GITHUB_OUTPUT
        id: set-npm-url
        run: |
          if [ -f .semanticRelease.npmPackage.deployedVersion.txt ]; then
            echo "npm-url=https://www.npmjs.com/package/@isdk/llama-node/v/$(cat .semanticRelease.npmPackage.deployedVersion.txt)" >> $GITHUB_OUTPUT
          fi
      - name: Set package version to GITHUB_OUTPUT
        id: set-package-version
        run: |
          if [ -f .semanticRelease.npmPackage.deployedVersion.txt ]; then
            echo "package-version=$(cat .semanticRelease.npmPackage.deployedVersion.txt)" >> $GITHUB_OUTPUT
          fi
